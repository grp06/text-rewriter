# RewriteText: Untangle Rewrite Flow With Use Case + Ports (Improve Testability)

This ExecPlan is a living document. The sections `Progress`, `Surprises & Discoveries`, `Decision Log`, and `Outcomes & Retrospective` must be kept up to date as work proceeds.

This repo does not include a root `PLANS.md`. Planning rules live in `.agent/PLANS.md`, and this ExecPlan must be maintained in accordance with `.agent/PLANS.md`.

## Purpose / Big Picture

After this change, RewriteText will behave exactly the same for users (menu bar app, preset selection, `Cmd+Shift+R` hotkey, highlight -> rewrite -> replace), but the core rewrite flow will no longer be “held hostage” by infrastructure. Specifically, `RewriteModel` will stop directly coordinating Keychain/env key lookup, clipboard + synthetic key events, and HTTP calls in one function. Instead, a dedicated “use case” object will orchestrate the workflow through small interfaces (“ports”), with concrete implementations (“adapters”) for macOS clipboard automation and OpenAI.

The user-visible way to see this working is unchanged: run the app, highlight text in another app, press `Cmd+Shift+R`, and the selection is replaced. The developer-visible improvement is that the rewrite workflow can be unit-tested with fakes without needing Accessibility permissions, pasteboard mutation, or real network calls.

Definitions used in this plan:

- “Use case”: a small object that represents a single user operation (here: “rewrite the current selection”) and orchestrates dependencies.
- “Port”: a Swift protocol defining what the use case needs (for example: “get selected text”, “rewrite text using an LLM”) without specifying how.
- “Adapter”: a concrete implementation of a port that talks to real infrastructure (Keychain, pasteboard, HTTP).

## Progress

- [x] (2026-02-13 17:08Z) Introduce ports + use case for rewrite-selection, with unit tests using fakes.
- [x] (2026-02-13 17:08Z) Refactor existing infrastructure to adapters conforming to the new ports (OpenAI client, selection rewriter, api key store/provider).
- [x] (2026-02-13 17:08Z) Refactor `RewriteModel` to call the use case and to contain only UI state + UI presentation (alerts/status), preserving current behavior.
- [x] (2026-02-13 17:08Z) Validate: `xcodebuild ... test` passes; app builds; manual end-to-end rewrite should behave the same (still requires API key + Accessibility permission).

## Surprises & Discoveries

- Observation: (fill in during implementation) Adding an XCTest target via XcodeGen may require small settings tweaks (test bundle identifier, host app, etc.).
  Evidence: (paste the xcodegen output or xcodebuild error and the fix).

- Observation: (fill in during implementation) Some infra types might not be usable from tests as-is (for example, `@MainActor` types or AppKit dependencies).
  Evidence: (paste the compiler error and the change made to isolate AppKit usage).

- Observation: XcodeGen did not generate a separate `RewriteTextTests` scheme, but `xcodebuild -scheme RewriteText test` still ran the unit tests successfully.
  Evidence: `xcodebuild -project RewriteText.xcodeproj -scheme RewriteText test` executed `RewriteTextTests.xctest` and ran 3 tests with 0 failures.

## Decision Log

- Decision: Create a small “use case + ports” boundary rather than doing a large architectural rewrite.
  Rationale: This codebase is tiny; the goal is to make the main flow testable and swappable without adding lots of files or abstractions.
  Date/Author: 2026-02-13 / Codex

- Decision: Add a minimal unit test target via XcodeGen to lock in behavior at the seam (call order and error mapping), rather than relying only on manual testing.
  Rationale: The main pain of the entanglement is testability. A small XCTest suite gives fast feedback and makes future changes safer.
  Date/Author: 2026-02-13 / Codex

## Outcomes & Retrospective

- Outcome: The rewrite-selection flow is now orchestrated by `RewriteSelectionUseCase` using ports (`APIKeyProviding`, `SelectionIO`, `LLMRewriting`). `RewriteModel` no longer directly calls pasteboard automation or OpenAI HTTP in the same function.

- Outcome: A unit test target was added and use case behavior is covered by 3 XCTest cases using fakes (no AppKit, no network).

- Remaining gap: Manual end-to-end behavior still depends on macOS Accessibility permission for synthetic Cmd+C/Cmd+V. This plan does not attempt to remove that dependency.

## Context and Orientation

This is a macOS SwiftUI menu bar app generated by XcodeGen.

The main flow today is implemented as a single orchestrated chain inside `/Users/georgepickett/rewrite-text/RewriteText/RewriteModel.swift`:

- `rewriteSelection()` does api key lookup, preset selection, clipboard capture/paste via synthetic key events, OpenAI HTTP call, and user alerting. It calls `/Users/georgepickett/rewrite-text/RewriteText/SelectionRewriter.swift` and `/Users/georgepickett/rewrite-text/RewriteText/OpenAIClient.swift`.
- The global hotkey is registered with Carbon in `/Users/georgepickett/rewrite-text/RewriteText/HotkeyManager.swift` and triggers `RewriteModel.rewriteSelection()`.

This plan will keep the existing adapters (Keychain/pasteboard/OpenAI) but reorganize the call graph so that `RewriteModel` only owns UI state (published properties, opening Settings, showing alerts) and delegates the workflow to a use case object.

## Plan of Work

First, add small Swift protocols (“ports”) to express what the rewrite workflow needs, and implement a new use case object that orchestrates: get api key, capture selection, call LLM rewrite, replace selection. This use case must not import AppKit and must not show alerts. It should communicate failures via a typed error or a small result object.

Second, adapt existing infrastructure code to conform to the ports:

- Wrap the existing OpenAI HTTP client in a rewriter adapter.
- Wrap the existing selection capture/replace logic in a selection I/O adapter.
- Wrap api key retrieval/storage into explicit providers/stores.

Third, refactor `RewriteModel` to construct these dependencies and call the use case. `RewriteModel` remains `@MainActor`, owns `isWorking`/`lastStatus`, and still shows alerts, but it no longer directly “knows” how to do pasteboard operations or HTTP.

Fourth, add unit tests for the use case using fake ports (no AppKit, no network) and validate that the app still builds and works end-to-end.

## Concrete Steps

All commands below assume working directory `/Users/georgepickett/rewrite-text`.

1. Add an XCTest target via XcodeGen.

   Edit `/Users/georgepickett/rewrite-text/project.yml` to add a unit test target `RewriteTextTests` that depends on the `RewriteText` app target. Create a new directory `/Users/georgepickett/rewrite-text/RewriteTextTests` for the tests.

   Regenerate the project:

       cd /Users/georgepickett/rewrite-text && xcodegen generate

   Confirm Xcode lists the new test target/scheme:

       cd /Users/georgepickett/rewrite-text && xcodebuild -list -project RewriteText.xcodeproj

2. Introduce ports and use cases (no AppKit imports).

   Create a new file `/Users/georgepickett/rewrite-text/RewriteText/RewritePorts.swift` that defines minimal protocols:

   - `APIKeyProviding` with a synchronous `func loadAPIKey() throws -> String?`
   - `SelectionIO` with `func captureSelectedText() async throws -> String` and `func replaceSelection(with text: String) async throws`
   - `LLMRewriting` with `func rewrite(apiKey: String, preset: PromptPreset, inputText: String) async throws -> String` and (optionally) `func smokeTest(apiKey: String) async throws -> String`

   Create a new file `/Users/georgepickett/rewrite-text/RewriteText/RewriteSelectionUseCase.swift` with a method like `run(preset: PromptPreset) async throws -> String` that:

   - loads the API key (error if missing)
   - captures the current selected text (error if missing)
   - calls the rewriter
   - replaces the selection with the result
   - returns the rewritten text (or returns a small `RewriteOutcome` with status text if that’s clearer)

   The use case should not know about menu UI, alerts, `UserDefaults`, or Keychain. It should only use the ports.

3. Add use case unit tests with fakes.

   Create `/Users/georgepickett/rewrite-text/RewriteTextTests/RewriteSelectionUseCaseTests.swift` and write tests that fail before implementation and pass after:

   - `test_missingAPIKey_throwsActionableError`: Fake key provider returns nil; expect the use case throws a specific error type or message that the UI can show.
   - `test_success_callsReplaceWithRewrittenText`: Fake selection returns "hello"; fake rewriter returns "hi"; fake selection IO records the replacement text; assert it equals "hi".
   - `test_usesProvidedPresetInstructions`: Fake rewriter records the preset passed; assert the preset is the one selected (for example `PromptPreset.builtins[0]`).

   Define fake implementations inside the test file. Keep them minimal and avoid shared mutable state beyond what the assertions need.

4. Refactor existing infrastructure into adapters.

   Update `/Users/georgepickett/rewrite-text/RewriteText/OpenAIClient.swift` (or wrap it) so that there is a type conforming to `LLMRewriting`. The adapter should call the existing `OpenAIClient.rewrite(...)` and `OpenAIClient.smokeTest(...)`.

   Update `/Users/georgepickett/rewrite-text/RewriteText/SelectionRewriter.swift` so that there is a type conforming to `SelectionIO`. Do not move synthetic key event logic into the use case; keep it entirely behind the adapter.

   Create api key provider(s) as adapters around:

   - environment variable `OPENAI_API_KEY`
   - Keychain storage (`KeychainStore`)

   Prefer a composite provider: env key wins if present, otherwise Keychain.

5. Refactor `RewriteModel` to delegate workflow.

   In `/Users/georgepickett/rewrite-text/RewriteText/RewriteModel.swift`:

   - Replace the direct orchestration in `rewriteSelection()` with:
     - UI state gating (`isWorking` and `lastStatus`)
     - selecting the current preset
     - invoking the use case with that preset
     - mapping errors into `lastStatus` and `showAlert(...)`
   - Keep `saveApiKey(...)` and `clearApiKey()` behavior the same, but route through the new api key store adapter if you introduced one.
   - Ensure `testApiKey()` uses the rewriter adapter (via a small `TestAPIKeyUseCase` or via the same OpenAI adapter directly) while preserving current Settings UI behavior.

6. Run tests and build.

   Run unit tests:

       cd /Users/georgepickett/rewrite-text && xcodebuild -project RewriteText.xcodeproj -scheme RewriteTextTests test

   If the generated scheme name differs, list schemes and pick the correct one:

       cd /Users/georgepickett/rewrite-text && xcodebuild -list -project RewriteText.xcodeproj

   Build the app:

       cd /Users/georgepickett/rewrite-text && xcodebuild -project RewriteText.xcodeproj -scheme RewriteText -configuration Debug build

## Validation and Acceptance

Acceptance is both behavior and structure:

1. Structure: `/Users/georgepickett/rewrite-text/RewriteText/RewriteModel.swift` no longer performs the selection capture/paste or HTTP request directly. Those side effects must be behind adapters used by a use case.

2. Tests: running the test command described in `Concrete Steps` passes (the use case tests run without AppKit or network).

3. Behavior: manual end-to-end still works:

- Launch the app; it appears in the menu bar.
- Set API key in Settings or set `OPENAI_API_KEY`.
- Grant Accessibility permission if prompted.
- In another app, highlight text and press `Cmd+Shift+R`; the selection is replaced with the rewrite.
- Switching presets changes rewrite output as before.

## Idempotence and Recovery

Regenerating the project with XcodeGen is safe and repeatable:

    cd /Users/georgepickett/rewrite-text && xcodegen generate

If adding the test target causes scheme confusion, always use `xcodebuild -list -project RewriteText.xcodeproj` to confirm the actual scheme names produced.

## Artifacts and Notes

Ports should be intentionally small. If a protocol has more than a few methods, it is likely mixing concerns and should be split.

Keep AppKit/UI code in `RewriteModel`, `SettingsView`, and menu views. Keep infrastructure details (pasteboard, Keychain, URLSession) behind adapters. Keep orchestration logic in the use case.

## Interfaces and Dependencies

No new third-party libraries. Use:

- Swift protocols for ports.
- Existing app infrastructure:
  - Keychain via `/Users/georgepickett/rewrite-text/RewriteText/KeychainStore.swift`
  - Pasteboard + synthetic key events via `/Users/georgepickett/rewrite-text/RewriteText/SelectionRewriter.swift`
  - OpenAI via `/Users/georgepickett/rewrite-text/RewriteText/OpenAIClient.swift`
- XCTest for unit tests via a new XcodeGen test target.

Change note: This plan is based on the current entanglement found in `RewriteModel.rewriteSelection()` and is intended to reduce boundary coupling without changing the user-visible workflow.
